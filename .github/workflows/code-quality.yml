name: Code Quality Checks

on:
  pull_request:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - '.github/workflows/code-quality.yml'
  push:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - '.github/workflows/code-quality.yml'

jobs:
  check-unwraps:
    name: Check for unwrap() in production code
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for unwrap() in production code
        run: |
          echo "üîç Scanning for unwrap() calls in production code..."

          # Find unwrap() calls excluding test files, comments, and archived services
          UNWRAPS=$(grep -rn "\.unwrap()" backend --include="*.rs" | \
                    grep -v "backend/archived-v1/" | \
                    grep -v "/tests/" | \
                    grep -v "_test.rs" | \
                    grep -v "test_" | \
                    grep -v "#\[test\]" | \
                    grep -v "#\[cfg(test)\]" | \
                    grep -v "^\s*//" | \
                    grep -v "build.rs" | \
                    grep -v "target/" | \
                    grep -v "examples/" || true)

          if [ -n "$UNWRAPS" ]; then
            echo "‚ùå Found unwrap() calls in production code:"
            echo "$UNWRAPS"
            echo ""
            echo "‚ö†Ô∏è  Please replace unwrap() with proper error handling:"
            echo "  - Use .context() for better error messages"
            echo "  - Use ? operator for error propagation"
            echo "  - Use .unwrap_or_default() if appropriate"
            exit 1
          else
            echo "‚úÖ No unwrap() calls found in production code"
          fi

  check-todos:
    name: Check for TODO comments
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for TODO comments
        run: |
          echo "üîç Scanning for TODO comments..."

          # Find TODO comments (warning only, not blocking)
          TODOS=$(grep -rn "TODO\|FIXME\|XXX\|HACK" backend --include="*.rs" | \
                  grep -v "target/" || true)

          if [ -n "$TODOS" ]; then
            TODO_COUNT=$(echo "$TODOS" | wc -l)
            echo "‚ö†Ô∏è  Found $TODO_COUNT TODO/FIXME comments:"
            echo "$TODOS" | head -10
            echo ""
            echo "Consider creating GitHub issues for these TODOs"
            # Not failing the build, just warning
          else
            echo "‚úÖ No TODO comments found"
          fi

  check-expect:
    name: Check for expect() without context
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for expect() calls
        run: |
          echo "üîç Scanning for expect() calls..."

          # Find expect() with generic messages
          BAD_EXPECTS=$(grep -rn '\.expect("' backend --include="*.rs" | \
                        grep -v "test" | \
                        grep -v "target/" | \
                        grep -E '\.expect\("(Failed|Error|Invalid)"\)' || true)

          if [ -n "$BAD_EXPECTS" ]; then
            echo "‚ö†Ô∏è  Found expect() calls with generic messages:"
            echo "$BAD_EXPECTS"
            echo ""
            echo "Please provide specific error context in expect() messages"
            # Warning only, not blocking
          else
            echo "‚úÖ All expect() calls have good error messages"
          fi

  check-hardcoded-secrets:
    name: Check for hardcoded secrets
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for potential hardcoded secrets
        run: |
          echo "üîç Scanning for potential hardcoded secrets..."

          # Check for suspicious patterns (excluding comments, tests, and archived services)
          SECRETS=$(grep -rn -E '(password|secret|api_key|token)\s*=\s*"[^"]+"' backend --include="*.rs" | \
                    grep -v "backend/archived-v1/" | \
                    grep -v "/tests/" | \
                    grep -v "_test.rs" | \
                    grep -v "test_" | \
                    grep -v "//" | \
                    grep -v "target/" | \
                    grep -v "examples/" || true)

          if [ -n "$SECRETS" ]; then
            echo "‚ùå Found potential hardcoded secrets:"
            echo "$SECRETS"
            echo ""
            echo "‚ö†Ô∏è  Security Issue: Use environment variables or secret management"
            exit 1
          else
            echo "‚úÖ No hardcoded secrets detected"
          fi

  check-println:
    name: Check for println! in production code
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for println! debugging
        run: |
          echo "üîç Scanning for println! statements..."

          # Find println! in non-test code (excluding archived services and examples)
          PRINTLNS=$(grep -rn "println!\|eprintln!" backend --include="*.rs" | \
                     grep -v "backend/archived-v1/" | \
                     grep -v "/tests/" | \
                     grep -v "_test.rs" | \
                     grep -v "test_" | \
                     grep -v "build.rs" | \
                     grep -v "target/" | \
                     grep -v "examples/" | \
                     grep -v "ERROR:" || true)

          if [ -n "$PRINTLNS" ]; then
            echo "‚ö†Ô∏è  Found println! statements in production code:"
            echo "$PRINTLNS"
            echo ""
            echo "Please use tracing macros instead (info!, warn!, error!)"
            # Warning only for now
          else
            echo "‚úÖ No println! statements found"
          fi

  check-panic:
    name: Check for panic! in production code
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for panic! calls
        run: |
          echo "üîç Scanning for panic! calls..."

          # Find panic! in production code, excluding tests and archived services
          PANICS=$(grep -rn "panic!" backend --include="*.rs" | \
                   grep -v "backend/archived-v1/" | \
                   grep -v "/tests/" | \
                   grep -v "_test.rs" | \
                   grep -v "test_" | \
                   grep -v "#\[test\]" | \
                   grep -v "#\[cfg(test)\]" | \
                   grep -v "unreachable!" | \
                   grep -v "target/" | \
                   grep -v "examples/" || true)

          if [ -n "$PANICS" ]; then
            echo "‚ùå Found panic! calls in production code:"
            echo "$PANICS"
            echo ""
            echo "‚ö†Ô∏è  Replace panic! with proper error handling"
            exit 1
          else
            echo "‚úÖ No panic! calls found"
          fi

  clippy:
    name: Clippy Lints
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          components: clippy

      - name: Run Clippy
        run: |
          cd backend
          cargo clippy --all-targets --all-features -- \
            -W clippy::unwrap_used \
            -W clippy::expect_used \
            -W clippy::panic \
            -W clippy::todo \
            -W clippy::unimplemented \
            -D warnings

  rustfmt:
    name: Format Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          components: rustfmt

      - name: Check Formatting
        run: |
          cd backend
          cargo fmt --all -- --check