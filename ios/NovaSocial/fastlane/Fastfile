# frozen_string_literal: true

# Fastfile for ICERED iOS App
# Documentation: https://docs.fastlane.tools

default_platform(:ios)

# Constants
APP_IDENTIFIER = "com.app.icered"
SCHEME = "ICERED-NoWidgets"
PROJECT_PATH = "ICERED.xcodeproj"

# Helper method to get App Store Connect API Key
def api_key
  app_store_connect_api_key(
    key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
    issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
    key_filepath: ENV["APP_STORE_CONNECT_API_KEY_KEY_FILEPATH"],
    in_house: false
  )
end

platform :ios do
  # ==================== Setup ====================

  desc "Setup development environment"
  lane :setup do
    setup_ci if is_ci

    # Sync certificates and profiles
    match(type: "development", readonly: is_ci, api_key: api_key)
    match(type: "appstore", readonly: is_ci, api_key: api_key)
  end

  # ==================== Code Signing ====================

  desc "Sync development certificates"
  lane :sync_dev_certs do
    match(type: "development", readonly: is_ci, api_key: api_key)
  end

  desc "Sync App Store certificates"
  lane :sync_appstore_certs do
    match(type: "appstore", readonly: is_ci, api_key: api_key)
  end

  desc "Force regenerate App Store provisioning profiles"
  lane :regenerate_profiles do
    match(
      type: "appstore",
      force: true,
      api_key: api_key,
      readonly: false
    )
    UI.success("Successfully regenerated provisioning profiles!")
  end

  desc "Register new devices and refresh profiles"
  lane :add_device do |options|
    device_name = options[:name] || UI.input("Device name: ")
    device_udid = options[:udid] || UI.input("Device UDID: ")

    register_devices(devices: { device_name => device_udid }, api_key: api_key)

    # Refresh development profiles
    match(type: "development", force_for_new_devices: true, api_key: api_key)
  end

  # ==================== Build ====================

  desc "Build the app for testing"
  lane :build do
    sync_dev_certs

    build_app(
      scheme: SCHEME,
      project: PROJECT_PATH,
      configuration: "Debug",
      skip_archive: true,
      skip_codesigning: false
    )
  end

  desc "Build for App Store / TestFlight (without widgets)"
  lane :build_release do
    # Sync appstore certs for main app only
    match(
      type: "appstore",
      app_identifier: APP_IDENTIFIER,
      api_key: api_key,
      force: true
    )

    # Increment build number
    increment_build_number(
      build_number: ENV["BUILD_NUMBER"] || (latest_testflight_build_number(api_key: api_key) + 1).to_s
    )

    # Update code signing only for the main app target
    update_code_signing_settings(
      use_automatic_signing: false,
      path: PROJECT_PATH,
      targets: ["ICERED"],
      team_id: "2C77AZCA8W",
      profile_name: "match AppStore #{APP_IDENTIFIER}",
      code_sign_identity: "Apple Distribution"
    )

    build_app(
      scheme: SCHEME,
      project: PROJECT_PATH,
      configuration: "Release",
      export_method: "app-store",
      skip_build_archive: false,
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}"
        }
      }
    )
  end

  # ==================== TestFlight ====================

  desc "Upload to TestFlight"
  lane :testflight_upload do |options|
    # Build release version
    build_release

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: options[:skip_waiting] || false,
      distribute_external: options[:external] || false,
      notify_external_testers: options[:notify] || false,
      changelog: options[:changelog] || "Bug fixes and improvements"
    )

    UI.success("Successfully uploaded to TestFlight!")
  end

  desc "Quick upload to TestFlight (skip waiting for processing)"
  lane :beta do |options|
    testflight_upload(
      skip_waiting: true,
      changelog: options[:changelog] || "New beta build"
    )
  end

  desc "Release to external testers on TestFlight"
  lane :beta_external do |options|
    testflight_upload(
      skip_waiting: false,
      external: true,
      notify: true,
      changelog: options[:changelog] || "New beta build for external testing"
    )
  end

  # ==================== App Store ====================

  desc "Submit to App Store for review"
  lane :release do |options|
    # Build if no IPA exists
    unless options[:skip_build]
      build_release
    end

    # Upload to App Store
    upload_to_app_store(
      api_key: api_key,
      skip_screenshots: options[:skip_screenshots] || true,
      skip_metadata: options[:skip_metadata] || false,
      submit_for_review: options[:submit] || false,
      automatic_release: options[:auto_release] || false,
      force: true
    )

    UI.success("Successfully uploaded to App Store!")
  end

  # ==================== Utility ====================

  desc "Increment version number"
  lane :bump_version do |options|
    bump_type = options[:type] || "patch"
    increment_version_number(bump_type: bump_type)

    version = get_version_number(target: SCHEME)
    UI.success("Version bumped to #{version}")
  end

  desc "Increment build number"
  lane :bump_build do
    increment_build_number
    build = get_build_number
    UI.success("Build number bumped to #{build}")
  end

  desc "Get the latest TestFlight build number"
  lane :latest_build do
    build_num = latest_testflight_build_number(api_key: api_key)
    UI.success("Latest TestFlight build number: #{build_num}")
    build_num
  end

  # ==================== Testing ====================

  desc "Run unit tests"
  lane :test do
    run_tests(
      scheme: SCHEME,
      project: PROJECT_PATH,
      device: "iPhone 16 Pro",
      clean: true
    )
  end

  # ==================== IceredTest (Pro) ====================

  desc "Build and upload to IceredTest TestFlight"
  lane :beta_pro do |options|
    pro_identifier = "com.app.icered.pro"

    # Sync appstore certs for pro app
    match(
      type: "appstore",
      app_identifier: pro_identifier,
      api_key: api_key,
      force: true
    )

    # Get latest build number for pro app
    build_num = latest_testflight_build_number(
      api_key: api_key,
      app_identifier: pro_identifier
    ) + 1

    # Increment build number
    increment_build_number(build_number: build_num.to_s)

    # Update code signing for the main app target with pro identifier
    update_code_signing_settings(
      use_automatic_signing: false,
      path: PROJECT_PATH,
      targets: ["ICERED"],
      team_id: "2C77AZCA8W",
      profile_name: "match AppStore #{pro_identifier}",
      code_sign_identity: "Apple Distribution",
      bundle_identifier: pro_identifier
    )

    build_app(
      scheme: SCHEME,
      project: PROJECT_PATH,
      configuration: "Release",
      export_method: "app-store",
      skip_build_archive: false,
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          pro_identifier => "match AppStore #{pro_identifier}"
        }
      }
    )

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      app_identifier: pro_identifier,
      skip_waiting_for_build_processing: true,
      changelog: options[:changelog] || "New beta build"
    )

    UI.success("Successfully uploaded to IceredTest TestFlight!")
  end

  # ==================== IceredTest with Widgets ====================

  desc "Build and upload to IceredTest TestFlight WITH widgets"
  lane :beta_pro_widgets do |options|
    pro_identifier = "com.app.icered.pro"
    widget_identifier = "com.app.icered.pro.widgets"

    # Sync appstore certs for both main app and widget
    match(
      type: "appstore",
      app_identifier: [pro_identifier, widget_identifier],
      api_key: api_key,
      force: true
    )

    # Get latest build number for pro app
    build_num = latest_testflight_build_number(
      api_key: api_key,
      app_identifier: pro_identifier
    ) + 1

    # Increment build number
    increment_build_number(build_number: build_num.to_s)

    # Update code signing for the main app target
    update_code_signing_settings(
      use_automatic_signing: false,
      path: PROJECT_PATH,
      targets: ["ICERED"],
      team_id: "2C77AZCA8W",
      profile_name: "match AppStore #{pro_identifier}",
      code_sign_identity: "Apple Distribution",
      bundle_identifier: pro_identifier
    )

    # Update code signing for the widget target
    update_code_signing_settings(
      use_automatic_signing: false,
      path: PROJECT_PATH,
      targets: ["ICEREDWidgets"],
      team_id: "2C77AZCA8W",
      profile_name: "match AppStore #{widget_identifier}",
      code_sign_identity: "Apple Distribution",
      bundle_identifier: widget_identifier
    )

    build_app(
      scheme: "ICERED",  # Use full scheme with widgets
      project: PROJECT_PATH,
      configuration: "Release",
      export_method: "app-store",
      skip_build_archive: false,
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          pro_identifier => "match AppStore #{pro_identifier}",
          widget_identifier => "match AppStore #{widget_identifier}"
        }
      }
    )

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      app_identifier: pro_identifier,
      skip_waiting_for_build_processing: true,
      changelog: options[:changelog] || "New beta build with widgets"
    )

    UI.success("Successfully uploaded to IceredTest TestFlight with widgets!")
  end

  # ==================== Error Handling ====================

  error do |lane, exception|
    UI.error("Lane #{lane} failed with error: #{exception.message}")
  end
end
